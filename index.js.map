{
  "version": 3,
  "sources": ["../node_modules/rfc4648/lib/index.js", "../node_modules/rfc4648/lib/index.mjs", "../node_modules/@cfworker/base64url/dist/decode.js", "../node_modules/@cfworker/base64url/dist/encode.js", "../node_modules/cbor-x/decode.js", "../src/utils.ts", "../src/client/api.ts", "../src/client/assertion.ts", "../src/crypto.ts", "../src/client/attestation.ts", "../src/client/dom.ts", "../src/client/index.ts"],
  "sourcesContent": ["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nfunction parse(string, encoding, opts) {\n  var _opts$out;\n\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  // Build the character lookup table:\n  if (!encoding.codes) {\n    encoding.codes = {};\n\n    for (var i = 0; i < encoding.chars.length; ++i) {\n      encoding.codes[encoding.chars[i]] = i;\n    }\n  } // The string must have a whole number of bytes:\n\n\n  if (!opts.loose && string.length * encoding.bits & 7) {\n    throw new SyntaxError('Invalid padding');\n  } // Count the padding bytes:\n\n\n  var end = string.length;\n\n  while (string[end - 1] === '=') {\n    --end; // If we get a whole number of bytes, there is too much padding:\n\n    if (!opts.loose && !((string.length - end) * encoding.bits & 7)) {\n      throw new SyntaxError('Invalid padding');\n    }\n  } // Allocate the output:\n\n\n  var out = new ((_opts$out = opts.out) != null ? _opts$out : Uint8Array)(end * encoding.bits / 8 | 0); // Parse the data:\n\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  var written = 0; // Next byte to write\n\n  for (var _i = 0; _i < end; ++_i) {\n    // Read one character from the string:\n    var value = encoding.codes[string[_i]];\n\n    if (value === undefined) {\n      throw new SyntaxError('Invalid character ' + string[_i]);\n    } // Append the bits to the buffer:\n\n\n    buffer = buffer << encoding.bits | value;\n    bits += encoding.bits; // Write out some bits if the buffer has a byte's worth:\n\n    if (bits >= 8) {\n      bits -= 8;\n      out[written++] = 0xff & buffer >> bits;\n    }\n  } // Verify that we have received just enough bits:\n\n\n  if (bits >= encoding.bits || 0xff & buffer << 8 - bits) {\n    throw new SyntaxError('Unexpected end of data');\n  }\n\n  return out;\n}\nfunction stringify(data, encoding, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n\n  var _opts = opts,\n      _opts$pad = _opts.pad,\n      pad = _opts$pad === void 0 ? true : _opts$pad;\n  var mask = (1 << encoding.bits) - 1;\n  var out = '';\n  var bits = 0; // Number of bits currently in the buffer\n\n  var buffer = 0; // Bits waiting to be written out, MSB first\n\n  for (var i = 0; i < data.length; ++i) {\n    // Slurp data into the buffer:\n    buffer = buffer << 8 | 0xff & data[i];\n    bits += 8; // Write out as much as we can:\n\n    while (bits > encoding.bits) {\n      bits -= encoding.bits;\n      out += encoding.chars[mask & buffer >> bits];\n    }\n  } // Partial character:\n\n\n  if (bits) {\n    out += encoding.chars[mask & buffer << encoding.bits - bits];\n  } // Add padding characters until we hit a byte boundary:\n\n\n  if (pad) {\n    while (out.length * encoding.bits & 7) {\n      out += '=';\n    }\n  }\n\n  return out;\n}\n\n/* eslint-disable @typescript-eslint/strict-boolean-expressions */\nvar base16Encoding = {\n  chars: '0123456789ABCDEF',\n  bits: 4\n};\nvar base32Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567',\n  bits: 5\n};\nvar base32HexEncoding = {\n  chars: '0123456789ABCDEFGHIJKLMNOPQRSTUV',\n  bits: 5\n};\nvar base64Encoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  bits: 6\n};\nvar base64UrlEncoding = {\n  chars: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_',\n  bits: 6\n};\nvar base16 = {\n  parse: function parse$1(string, opts) {\n    return parse(string.toUpperCase(), base16Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base16Encoding, opts);\n  }\n};\nvar base32 = {\n  parse: function parse$1(string, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    return parse(opts.loose ? string.toUpperCase().replace(/0/g, 'O').replace(/1/g, 'L').replace(/8/g, 'B') : string, base32Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32Encoding, opts);\n  }\n};\nvar base32hex = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base32HexEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base32HexEncoding, opts);\n  }\n};\nvar base64 = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64Encoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64Encoding, opts);\n  }\n};\nvar base64url = {\n  parse: function parse$1(string, opts) {\n    return parse(string, base64UrlEncoding, opts);\n  },\n  stringify: function stringify$1(data, opts) {\n    return stringify(data, base64UrlEncoding, opts);\n  }\n};\nvar codec = {\n  parse: parse,\n  stringify: stringify\n};\n\nexports.base16 = base16;\nexports.base32 = base32;\nexports.base32hex = base32hex;\nexports.base64 = base64;\nexports.base64url = base64url;\nexports.codec = codec;\n", "// Generated by rollup-plugin-mjs-entry\n\nimport cjs from './index.js';\n\nexport const base16 = cjs.base16;\nexport const base32 = cjs.base32;\nexport const base32hex = cjs.base32hex;\nexport const base64 = cjs.base64;\nexport const base64url = cjs.base64url;\nexport const codec = cjs.codec;\nexport default cjs;\n", "import { base64url } from 'rfc4648';\nexport function decode(s) {\n    return new TextDecoder().decode(base64url.parse(s, { loose: true }));\n}\n", "import { base64url } from 'rfc4648';\nexport function encode(s) {\n    return base64url.stringify(new TextEncoder().encode(s), { pad: false });\n}\n", "let decoder\ntry {\n\tdecoder = new TextDecoder()\n} catch(error) {}\nlet src\nlet srcEnd\nlet position = 0\nlet alreadySet\nconst EMPTY_ARRAY = []\nconst LEGACY_RECORD_INLINE_ID = 105\nconst RECORD_DEFINITIONS_ID = 0xdffe\nconst RECORD_INLINE_ID = 0xdfff // temporary first-come first-serve tag // proposed tag: 0x7265 // 're'\nconst BUNDLED_STRINGS_ID = 0xdff9\nconst PACKED_TABLE_TAG_ID = 51\nconst PACKED_REFERENCE_TAG_ID = 6\nconst STOP_CODE = {}\nlet strings = EMPTY_ARRAY\nlet stringPosition = 0\nlet currentDecoder = {}\nlet currentStructures\nlet srcString\nlet srcStringStart = 0\nlet srcStringEnd = 0\nlet bundledStrings\nlet referenceMap\nlet currentExtensions = []\nlet currentExtensionRanges = []\nlet packedValues\nlet dataView\nlet restoreMapsAsObject\nlet defaultOptions = {\n\tuseRecords: false,\n\tmapsAsObjects: true\n}\nlet sequentialMode = false\n\nexport class Decoder {\n\tconstructor(options) {\n\t\tif (options) {\n\t\t\tif ((options.keyMap || options._keyMap) && !options.useRecords) {\n\t\t\t\toptions.useRecords = false\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\t}\n\t\t\tif (options.useRecords === false && options.mapsAsObjects === undefined)\n\t\t\t\toptions.mapsAsObjects = true\n\t\t\tif (options.getStructures)\n\t\t\t\toptions.getShared = options.getStructures\n\t\t\tif (options.getShared && !options.structures)\n\t\t\t\t(options.structures = []).uninitialized = true // this is what we use to denote an uninitialized structures\n\t\t\tif (options.keyMap) {\n\t\t\t\tthis.mapKey = new Map()\n\t\t\t\tfor (let [k,v] of Object.entries(options.keyMap)) this.mapKey.set(v,k)\n\t\t\t}\n\t\t}\n\t\tObject.assign(this, options)\n\t}\n\t/*\n\tdecodeKey(key) {\n\t\treturn this.keyMap\n\t\t\t? Object.keys(this.keyMap)[Object.values(this.keyMap).indexOf(key)] || key\n\t\t\t: key\n\t}\n\t*/\n\tdecodeKey(key) {\n\t\treturn this.keyMap ? this.mapKey.get(key) || key : key\n\t}\n\t\n\tencodeKey(key) {\n\t\treturn this.keyMap && this.keyMap.hasOwnProperty(key) ? this.keyMap[key] : key\n\t}\n\n\tencodeKeys(rec) {\n\t\tif (!this._keyMap) return rec\n\t\tlet map = new Map()\n\t\tfor (let [k,v] of Object.entries(rec)) map.set((this._keyMap.hasOwnProperty(k) ? this._keyMap[k] : k), v)\n\t\treturn map\n\t}\n\n\tdecodeKeys(map) {\n\t\tif (!this._keyMap || map.constructor.name != 'Map') return map\n\t\tif (!this._mapKey) {\n\t\t\tthis._mapKey = new Map()\n\t\t\tfor (let [k,v] of Object.entries(this._keyMap)) this._mapKey.set(v,k)\n\t\t}\n\t\tlet res = {}\n\t\t//map.forEach((v,k) => res[Object.keys(this._keyMap)[Object.values(this._keyMap).indexOf(k)] || k] = v)\n\t\tmap.forEach((v,k) => res[safeKey(this._mapKey.has(k) ? this._mapKey.get(k) : k)] =  v)\n\t\treturn res\n\t}\n\t\n\tmapDecode(source, end) {\n\t\n\t\tlet res = this.decode(source)\n\t\tif (this._keyMap) { \n\t\t\t//Experiemntal support for Optimised KeyMap  decoding \n\t\t\tswitch (res.constructor.name) {\n\t\t\t\tcase 'Array': return res.map(r => this.decodeKeys(r))\n\t\t\t\t//case 'Map': return this.decodeKeys(res)\n\t\t\t}\n\t\t}\n\t\treturn res\n\t}\n\n\tdecode(source, end) {\n\t\tif (src) {\n\t\t\t// re-entrant execution, save the state and restore it after we do this decode\n\t\t\treturn saveState(() => {\n\t\t\t\tclearSource()\n\t\t\t\treturn this ? this.decode(source, end) : Decoder.prototype.decode.call(defaultOptions, source, end)\n\t\t\t})\n\t\t}\n\t\tsrcEnd = end > -1 ? end : source.length\n\t\tposition = 0\n\t\tstringPosition = 0\n\t\tsrcStringEnd = 0\n\t\tsrcString = null\n\t\tstrings = EMPTY_ARRAY\n\t\tbundledStrings = null\n\t\tsrc = source\n\t\t// this provides cached access to the data view for a buffer if it is getting reused, which is a recommend\n\t\t// technique for getting data from a database where it can be copied into an existing buffer instead of creating\n\t\t// new ones\n\t\ttry {\n\t\t\tdataView = source.dataView || (source.dataView = new DataView(source.buffer, source.byteOffset, source.byteLength))\n\t\t} catch(error) {\n\t\t\t// if it doesn't have a buffer, maybe it is the wrong type of object\n\t\t\tsrc = null\n\t\t\tif (source instanceof Uint8Array)\n\t\t\t\tthrow error\n\t\t\tthrow new Error('Source must be a Uint8Array or Buffer but was a ' + ((source && typeof source == 'object') ? source.constructor.name : typeof source))\n\t\t}\n\t\tif (this instanceof Decoder) {\n\t\t\tcurrentDecoder = this\n\t\t\tpackedValues = this.sharedValues &&\n\t\t\t\t(this.pack ? new Array(this.maxPrivatePackedValues || 16).concat(this.sharedValues) :\n\t\t\t\tthis.sharedValues)\n\t\t\tif (this.structures) {\n\t\t\t\tcurrentStructures = this.structures\n\t\t\t\treturn checkedRead()\n\t\t\t} else if (!currentStructures || currentStructures.length > 0) {\n\t\t\t\tcurrentStructures = []\n\t\t\t}\n\t\t} else {\n\t\t\tcurrentDecoder = defaultOptions\n\t\t\tif (!currentStructures || currentStructures.length > 0)\n\t\t\t\tcurrentStructures = []\n\t\t\tpackedValues = null\n\t\t}\n\t\treturn checkedRead()\n\t}\n\tdecodeMultiple(source, forEach) {\n\t\tlet values, lastPosition = 0\n\t\ttry {\n\t\t\tlet size = source.length\n\t\t\tsequentialMode = true\n\t\t\tlet value = this ? this.decode(source, size) : defaultDecoder.decode(source, size)\n\t\t\tif (forEach) {\n\t\t\t\tif (forEach(value) === false) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tif (forEach(checkedRead()) === false) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tvalues = [ value ]\n\t\t\t\twhile(position < size) {\n\t\t\t\t\tlastPosition = position\n\t\t\t\t\tvalues.push(checkedRead())\n\t\t\t\t}\n\t\t\t\treturn values\n\t\t\t}\n\t\t} catch(error) {\n\t\t\terror.lastPosition = lastPosition\n\t\t\terror.values = values\n\t\t\tthrow error\n\t\t} finally {\n\t\t\tsequentialMode = false\n\t\t\tclearSource()\n\t\t}\n\t}\n}\nexport function getPosition() {\n\treturn position\n}\nexport function checkedRead() {\n\ttry {\n\t\tlet result = read()\n\t\tif (bundledStrings) {\n\t\t\tif (position >= bundledStrings.postBundlePosition) {\n\t\t\t\tlet error = new Error('Unexpected bundle position');\n\t\t\t\terror.incomplete = true;\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\t// bundled strings to skip past\n\t\t\tposition = bundledStrings.postBundlePosition;\n\t\t\tbundledStrings = null;\n\t\t}\n\n\t\tif (position == srcEnd) {\n\t\t\t// finished reading this source, cleanup references\n\t\t\tcurrentStructures = null\n\t\t\tsrc = null\n\t\t\tif (referenceMap)\n\t\t\t\treferenceMap = null\n\t\t} else if (position > srcEnd) {\n\t\t\t// over read\n\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\terror.incomplete = true\n\t\t\tthrow error\n\t\t} else if (!sequentialMode) {\n\t\t\tthrow new Error('Data read, but end of buffer not reached')\n\t\t}\n\t\t// else more to read, but we are reading sequentially, so don't clear source yet\n\t\treturn result\n\t} catch(error) {\n\t\tclearSource()\n\t\tif (error instanceof RangeError || error.message.startsWith('Unexpected end of buffer')) {\n\t\t\terror.incomplete = true\n\t\t}\n\t\tthrow error\n\t}\n}\n\nexport function read() {\n\tlet token = src[position++]\n\tlet majorType = token >> 5\n\ttoken = token & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\treturn getFloat16()\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat32(position)\n\t\t\t\t\tif (currentDecoder.useFloat32 > 2) {\n\t\t\t\t\t\t// this does rounding of numbers that were encoded in 32-bit float to nearest significant decimal digit that could be preserved\n\t\t\t\t\t\tlet multiplier = mult10[((src[position] & 0x7f) << 1) | (src[position + 1] >> 7)]\n\t\t\t\t\t\tposition += 4\n\t\t\t\t\t\treturn ((multiplier * value + (value > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n\t\t\t\t\t}\n\t\t\t\t\tposition += 4\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t\tcase 0x1b:\n\t\t\t\tif (majorType == 7) {\n\t\t\t\t\tlet value = dataView.getFloat64(position)\n\t\t\t\t\tposition += 8\n\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\tif (majorType > 1) {\n\t\t\t\t\tif (dataView.getUint32(position) > 0)\n\t\t\t\t\t\tthrow new Error('JavaScript does not support arrays, maps, or strings with length over 4294967295')\n\t\t\t\t\ttoken = dataView.getUint32(position + 4)\n\t\t\t\t} else if (currentDecoder.int64AsNumber) {\n\t\t\t\t\ttoken = dataView.getUint32(position) * 0x100000000\n\t\t\t\t\ttoken += dataView.getUint32(position + 4)\n\t\t\t\t} else\n\t\t\t\t\ttoken = dataView.getBigUint64(position)\n\t\t\t\tposition += 8\n\t\t\t\tbreak\n\t\t\tcase 0x1f: \n\t\t\t\t// indefinite length\n\t\t\t\tswitch(majorType) {\n\t\t\t\t\tcase 2: // byte string\n\t\t\t\t\tcase 3: // text string\n\t\t\t\t\t\tthrow new Error('Indefinite length not supported for byte or text strings')\n\t\t\t\t\tcase 4: // array\n\t\t\t\t\t\tlet array = []\n\t\t\t\t\t\tlet value, i = 0\n\t\t\t\t\t\twhile ((value = read()) != STOP_CODE) {\n\t\t\t\t\t\t\tarray[i++] = value\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn majorType == 4 ? array : majorType == 3 ? array.join('') : Buffer.concat(array)\n\t\t\t\t\tcase 5: // map\n\t\t\t\t\t\tlet key\n\t\t\t\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\t\t\t\tlet object = {}\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) object[safeKey(currentDecoder.decodeKey(key))] = read()\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) object[safeKey(key)] = read()\n\t\t\t\t\t\t\treturn object\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlet map = new Map()\n\t\t\t\t\t\t\tif (currentDecoder.keyMap) while((key = read()) != STOP_CODE) map.set(currentDecoder.decodeKey(key), read())\n\t\t\t\t\t\t\telse while ((key = read()) != STOP_CODE) map.set(key, read())\n\t\t\t\t\t\t\treturn map\n\t\t\t\t\t\t}\n\t\t\t\t\tcase 7:\n\t\t\t\t\t\treturn STOP_CODE\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new Error('Invalid major type for indefinite length ' + majorType)\n\t\t\t\t}\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t}\n\t}\n\tswitch (majorType) {\n\t\tcase 0: // positive int\n\t\t\treturn token\n\t\tcase 1: // negative int\n\t\t\treturn ~token\n\t\tcase 2: // buffer\n\t\t\treturn readBin(token)\n\t\tcase 3: // string\n\t\t\tif (srcStringEnd >= position) {\n\t\t\t\treturn srcString.slice(position - srcStringStart, (position += token) - srcStringStart)\n\t\t\t}\n\t\t\tif (srcStringEnd == 0 && srcEnd < 140 && token < 32) {\n\t\t\t\t// for small blocks, avoiding the overhead of the extract call is helpful\n\t\t\t\tlet string = token < 16 ? shortStringInJS(token) : longStringInJS(token)\n\t\t\t\tif (string != null)\n\t\t\t\t\treturn string\n\t\t\t}\n\t\t\treturn readFixedString(token)\n\t\tcase 4: // array\n\t\t\tlet array = new Array(token)\n\t\t  //if (currentDecoder.keyMap) for (let i = 0; i < token; i++) array[i] = currentDecoder.decodeKey(read())\t\n\t\t\t//else \n\t\t\tfor (let i = 0; i < token; i++) array[i] = read()\n\t\t\treturn array\n\t\tcase 5: // map\n\t\t\tif (currentDecoder.mapsAsObjects) {\n\t\t\t\tlet object = {}\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) object[safeKey(currentDecoder.decodeKey(read()))] = read()\n\t\t\t\telse for (let i = 0; i < token; i++) object[safeKey(read())] = read()\n\t\t\t\treturn object\n\t\t\t} else {\n\t\t\t\tif (restoreMapsAsObject) {\n\t\t\t\t\tcurrentDecoder.mapsAsObjects = true\n\t\t\t\t\trestoreMapsAsObject = false\n\t\t\t\t}\n\t\t\t\tlet map = new Map()\n\t\t\t\tif (currentDecoder.keyMap) for (let i = 0; i < token; i++) map.set(currentDecoder.decodeKey(read()),read())\n\t\t\t\telse for (let i = 0; i < token; i++) map.set(read(), read())\n\t\t\t\treturn map\n\t\t\t}\n\t\tcase 6: // extension\n\t\t\tif (token >= BUNDLED_STRINGS_ID) {\n\t\t\t\tlet structure = currentStructures[token & 0x1fff] // check record structures first\n\t\t\t\t// At some point we may provide an option for dynamic tag assignment with a range like token >= 8 && (token < 16 || (token > 0x80 && token < 0xc0) || (token > 0x130 && token < 0x4000))\n\t\t\t\tif (structure) {\n\t\t\t\t\tif (!structure.read) structure.read = createStructureReader(structure)\n\t\t\t\t\treturn structure.read()\n\t\t\t\t}\n\t\t\t\tif (token < 0x10000) {\n\t\t\t\t\tif (token == RECORD_INLINE_ID) // we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\t\t\t\t\treturn recordDefinition(read())\n\t\t\t\t\telse if (token == RECORD_DEFINITIONS_ID) {\n\t\t\t\t\t\tlet length = readJustLength()\n\t\t\t\t\t\tlet id = read()\n\t\t\t\t\t\tfor (let i = 2; i < length; i++) {\n\t\t\t\t\t\t\trecordDefinition([id++, read()])\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn read()\n\t\t\t\t\t} else if (token == BUNDLED_STRINGS_ID) {\n\t\t\t\t\t\treturn readBundleExt()\n\t\t\t\t\t}\n\t\t\t\t\tif (currentDecoder.getShared) {\n\t\t\t\t\t\tloadShared()\n\t\t\t\t\t\tstructure = currentStructures[token & 0x1fff]\n\t\t\t\t\t\tif (structure) {\n\t\t\t\t\t\t\tif (!structure.read)\n\t\t\t\t\t\t\t\tstructure.read = createStructureReader(structure)\n\t\t\t\t\t\t\treturn structure.read()\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet extension = currentExtensions[token]\n\t\t\tif (extension) {\n\t\t\t\tif (extension.handlesRead)\n\t\t\t\t\treturn extension(read)\n\t\t\t\telse\n\t\t\t\t\treturn extension(read())\n\t\t\t} else {\n\t\t\t\tlet input = read()\n\t\t\t\tfor (let i = 0; i < currentExtensionRanges.length; i++) {\n\t\t\t\t\tlet value = currentExtensionRanges[i](token, input)\n\t\t\t\t\tif (value !== undefined)\n\t\t\t\t\t\treturn value\n\t\t\t\t}\n\t\t\t\treturn new Tag(input, token)\n\t\t\t}\n\t\tcase 7: // fixed value\n\t\t\tswitch (token) {\n\t\t\t\tcase 0x14: return false\n\t\t\t\tcase 0x15: return true\n\t\t\t\tcase 0x16: return null\n\t\t\t\tcase 0x17: return; // undefined\n\t\t\t\tcase 0x1f:\n\t\t\t\tdefault:\n\t\t\t\t\tlet packedValue = (packedValues || getPackedValues())[token]\n\t\t\t\t\tif (packedValue !== undefined)\n\t\t\t\t\t\treturn packedValue\n\t\t\t\t\tthrow new Error('Unknown token ' + token)\n\t\t\t}\n\t\tdefault: // negative int\n\t\t\tif (isNaN(token)) {\n\t\t\t\tlet error = new Error('Unexpected end of CBOR data')\n\t\t\t\terror.incomplete = true\n\t\t\t\tthrow error\n\t\t\t}\n\t\t\tthrow new Error('Unknown CBOR token ' + token)\n\t}\n}\nconst validName = /^[a-zA-Z_$][a-zA-Z\\d_$]*$/\nfunction createStructureReader(structure) {\n\tfunction readObject() {\n\t\t// get the array size from the header\n\t\tlet length = src[position++]\n\t\t//let majorType = token >> 5\n\t\tlength = length & 0x1f\n\t\tif (length > 0x17) {\n\t\t\tswitch (length) {\n\t\t\t\tcase 0x18:\n\t\t\t\t\tlength = src[position++]\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x19:\n\t\t\t\t\tlength = dataView.getUint16(position)\n\t\t\t\t\tposition += 2\n\t\t\t\t\tbreak\n\t\t\t\tcase 0x1a:\n\t\t\t\t\tlength = dataView.getUint32(position)\n\t\t\t\t\tposition += 4\n\t\t\t\t\tbreak\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error('Expected array header, but got ' + src[position - 1])\n\t\t\t}\n\t\t}\n\t\t// This initial function is quick to instantiate, but runs slower. After several iterations pay the cost to build the faster function\n\t\tlet compiledReader = this.compiledReader // first look to see if we have the fast compiled function\n\t\twhile(compiledReader) {\n\t\t\t// we have a fast compiled object literal reader\n\t\t\tif (compiledReader.propertyCount === length)\n\t\t\t\treturn compiledReader(read) // with the right length, so we use it\n\t\t\tcompiledReader = compiledReader.next // see if there is another reader with the right length\n\t\t}\n\t\tif (this.slowReads++ >= 3) { // create a fast compiled reader\n\t\t\tlet array = this.length == length ? this : this.slice(0, length)\n\t\t\tcompiledReader = currentDecoder.keyMap \n\t\t\t? new Function('r', 'return {' + array.map(k => currentDecoder.decodeKey(k)).map(k => validName.test(k) ? safeKey(k) + ':r()' : ('[' + JSON.stringify(k) + ']:r()')).join(',') + '}')\n\t\t\t: new Function('r', 'return {' + array.map(key => validName.test(key) ? safeKey(key) + ':r()' : ('[' + JSON.stringify(key) + ']:r()')).join(',') + '}')\n\t\t\tif (this.compiledReader)\n\t\t\t\tcompiledReader.next = this.compiledReader // if there is an existing one, we store multiple readers as a linked list because it is usually pretty rare to have multiple readers (of different length) for the same structure\n\t\t\tcompiledReader.propertyCount = length\n\t\t\tthis.compiledReader = compiledReader\n\t\t\treturn compiledReader(read)\n\t\t}\n\t\tlet object = {}\n\t\tif (currentDecoder.keyMap) for (let i = 0; i < length; i++) object[safeKey(currentDecoder.decodeKey(this[i]))] = read()\n\t\telse for (let i = 0; i < length; i++) {\n\t\t\tobject[safeKey(this[i])] = read();\n\t\t}\n\t\treturn object\n\t}\n\tstructure.slowReads = 0\n\treturn readObject\n}\n\nfunction safeKey(key) {\n\treturn key === '__proto__' ? '__proto_' : key\n}\n\nlet readFixedString = readStringJS\nlet readString8 = readStringJS\nlet readString16 = readStringJS\nlet readString32 = readStringJS\n\nexport let isNativeAccelerationEnabled = false\nexport function setExtractor(extractStrings) {\n\tisNativeAccelerationEnabled = true\n\treadFixedString = readString(1)\n\treadString8 = readString(2)\n\treadString16 = readString(3)\n\treadString32 = readString(5)\n\tfunction readString(headerLength) {\n\t\treturn function readString(length) {\n\t\t\tlet string = strings[stringPosition++]\n\t\t\tif (string == null) {\n\t\t\t\tif (bundledStrings)\n\t\t\t\t\treturn readStringJS(length)\n\t\t\t\tlet extraction = extractStrings(position, srcEnd, length, src)\n\t\t\t\tif (typeof extraction == 'string') {\n\t\t\t\t\tstring = extraction\n\t\t\t\t\tstrings = EMPTY_ARRAY\n\t\t\t\t} else {\n\t\t\t\t\tstrings = extraction\n\t\t\t\t\tstringPosition = 1\n\t\t\t\t\tsrcStringEnd = 1 // even if a utf-8 string was decoded, must indicate we are in the midst of extracted strings and can't skip strings\n\t\t\t\t\tstring = strings[0]\n\t\t\t\t\tif (string === undefined)\n\t\t\t\t\t\tthrow new Error('Unexpected end of buffer')\n\t\t\t\t}\n\t\t\t}\n\t\t\tlet srcStringLength = string.length\n\t\t\tif (srcStringLength <= length) {\n\t\t\t\tposition += length\n\t\t\t\treturn string\n\t\t\t}\n\t\t\tsrcString = string\n\t\t\tsrcStringStart = position\n\t\t\tsrcStringEnd = position + srcStringLength\n\t\t\tposition += length\n\t\t\treturn string.slice(0, length) // we know we just want the beginning\n\t\t}\n\t}\n}\nfunction readStringJS(length) {\n\tlet result\n\tif (length < 16) {\n\t\tif (result = shortStringInJS(length))\n\t\t\treturn result\n\t}\n\tif (length > 64 && decoder)\n\t\treturn decoder.decode(src.subarray(position, position += length))\n\tconst end = position + length\n\tconst units = []\n\tresult = ''\n\twhile (position < end) {\n\t\tconst byte1 = src[position++]\n\t\tif ((byte1 & 0x80) === 0) {\n\t\t\t// 1 byte\n\t\t\tunits.push(byte1)\n\t\t} else if ((byte1 & 0xe0) === 0xc0) {\n\t\t\t// 2 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 6) | byte2)\n\t\t} else if ((byte1 & 0xf0) === 0xe0) {\n\t\t\t// 3 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tunits.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3)\n\t\t} else if ((byte1 & 0xf8) === 0xf0) {\n\t\t\t// 4 bytes\n\t\t\tconst byte2 = src[position++] & 0x3f\n\t\t\tconst byte3 = src[position++] & 0x3f\n\t\t\tconst byte4 = src[position++] & 0x3f\n\t\t\tlet unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4\n\t\t\tif (unit > 0xffff) {\n\t\t\t\tunit -= 0x10000\n\t\t\t\tunits.push(((unit >>> 10) & 0x3ff) | 0xd800)\n\t\t\t\tunit = 0xdc00 | (unit & 0x3ff)\n\t\t\t}\n\t\t\tunits.push(unit)\n\t\t} else {\n\t\t\tunits.push(byte1)\n\t\t}\n\n\t\tif (units.length >= 0x1000) {\n\t\t\tresult += fromCharCode.apply(String, units)\n\t\t\tunits.length = 0\n\t\t}\n\t}\n\n\tif (units.length > 0) {\n\t\tresult += fromCharCode.apply(String, units)\n\t}\n\n\treturn result\n}\nlet fromCharCode = String.fromCharCode\nfunction longStringInJS(length) {\n\tlet start = position\n\tlet bytes = new Array(length)\n\tfor (let i = 0; i < length; i++) {\n\t\tconst byte = src[position++];\n\t\tif ((byte & 0x80) > 0) {\n\t\t\tposition = start\n    \t\t\treturn\n    \t\t}\n    \t\tbytes[i] = byte\n    \t}\n    \treturn fromCharCode.apply(String, bytes)\n}\nfunction shortStringInJS(length) {\n\tif (length < 4) {\n\t\tif (length < 2) {\n\t\t\tif (length === 0)\n\t\t\t\treturn ''\n\t\t\telse {\n\t\t\t\tlet a = src[position++]\n\t\t\t\tif ((a & 0x80) > 1) {\n\t\t\t\t\tposition -= 1\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a)\n\t\t\t}\n\t\t} else {\n\t\t\tlet a = src[position++]\n\t\t\tlet b = src[position++]\n\t\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0) {\n\t\t\t\tposition -= 2\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 3)\n\t\t\t\treturn fromCharCode(a, b)\n\t\t\tlet c = src[position++]\n\t\t\tif ((c & 0x80) > 0) {\n\t\t\t\tposition -= 3\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c)\n\t\t}\n\t} else {\n\t\tlet a = src[position++]\n\t\tlet b = src[position++]\n\t\tlet c = src[position++]\n\t\tlet d = src[position++]\n\t\tif ((a & 0x80) > 0 || (b & 0x80) > 0 || (c & 0x80) > 0 || (d & 0x80) > 0) {\n\t\t\tposition -= 4\n\t\t\treturn\n\t\t}\n\t\tif (length < 6) {\n\t\t\tif (length === 4)\n\t\t\t\treturn fromCharCode(a, b, c, d)\n\t\t\telse {\n\t\t\t\tlet e = src[position++]\n\t\t\t\tif ((e & 0x80) > 0) {\n\t\t\t\t\tposition -= 5\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e)\n\t\t\t}\n\t\t} else if (length < 8) {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0) {\n\t\t\t\tposition -= 6\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 7)\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f)\n\t\t\tlet g = src[position++]\n\t\t\tif ((g & 0x80) > 0) {\n\t\t\t\tposition -= 7\n\t\t\t\treturn\n\t\t\t}\n\t\t\treturn fromCharCode(a, b, c, d, e, f, g)\n\t\t} else {\n\t\t\tlet e = src[position++]\n\t\t\tlet f = src[position++]\n\t\t\tlet g = src[position++]\n\t\t\tlet h = src[position++]\n\t\t\tif ((e & 0x80) > 0 || (f & 0x80) > 0 || (g & 0x80) > 0 || (h & 0x80) > 0) {\n\t\t\t\tposition -= 8\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif (length < 10) {\n\t\t\t\tif (length === 8)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h)\n\t\t\t\telse {\n\t\t\t\t\tlet i = src[position++]\n\t\t\t\t\tif ((i & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 9\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i)\n\t\t\t\t}\n\t\t\t} else if (length < 12) {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0) {\n\t\t\t\t\tposition -= 10\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 11)\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j)\n\t\t\t\tlet k = src[position++]\n\t\t\t\tif ((k & 0x80) > 0) {\n\t\t\t\t\tposition -= 11\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k)\n\t\t\t} else {\n\t\t\t\tlet i = src[position++]\n\t\t\t\tlet j = src[position++]\n\t\t\t\tlet k = src[position++]\n\t\t\t\tlet l = src[position++]\n\t\t\t\tif ((i & 0x80) > 0 || (j & 0x80) > 0 || (k & 0x80) > 0 || (l & 0x80) > 0) {\n\t\t\t\t\tposition -= 12\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tif (length < 14) {\n\t\t\t\t\tif (length === 12)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l)\n\t\t\t\t\telse {\n\t\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\t\tif ((m & 0x80) > 0) {\n\t\t\t\t\t\t\tposition -= 13\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m)\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tlet m = src[position++]\n\t\t\t\t\tlet n = src[position++]\n\t\t\t\t\tif ((m & 0x80) > 0 || (n & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 14\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\tif (length < 15)\n\t\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n)\n\t\t\t\t\tlet o = src[position++]\n\t\t\t\t\tif ((o & 0x80) > 0) {\n\t\t\t\t\t\tposition -= 15\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\t\t\t\t\treturn fromCharCode(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction readBin(length) {\n\treturn currentDecoder.copyBuffers ?\n\t\t// specifically use the copying slice (not the node one)\n\t\tUint8Array.prototype.slice.call(src, position, position += length) :\n\t\tsrc.subarray(position, position += length)\n}\nfunction readExt(length) {\n\tlet type = src[position++]\n\tif (currentExtensions[type]) {\n\t\treturn currentExtensions[type](src.subarray(position, position += length))\n\t}\n\telse\n\t\tthrow new Error('Unknown extension type ' + type)\n}\nlet f32Array = new Float32Array(1)\nlet u8Array = new Uint8Array(f32Array.buffer, 0, 4)\nfunction getFloat16() {\n\tlet byte0 = src[position++]\n\tlet byte1 = src[position++]\n\tlet exponent = (byte0 & 0x7f) >> 2;\n\tif (exponent === 0x1f) { // specials\n\t\tif (byte1 || (byte0 & 3))\n\t\t\treturn NaN;\n\t\treturn (byte0 & 0x80) ? -Infinity : Infinity;\n\t}\n\tif (exponent === 0) { // sub-normals\n\t\t// significand with 10 fractional bits and divided by 2^14\n\t\tlet abs = (((byte0 & 3) << 8) | byte1) / (1 << 24)\n\t\treturn (byte0 & 0x80) ? -abs : abs\n\t}\n\n\tu8Array[3] = (byte0 & 0x80) | // sign bit\n\t\t((exponent >> 1) + 56) // 4 of 5 of the exponent bits, re-offset-ed\n\tu8Array[2] = ((byte0 & 7) << 5) | // last exponent bit and first two mantissa bits\n\t\t(byte1 >> 3) // next 5 bits of mantissa\n\tu8Array[1] = byte1 << 5; // last three bits of mantissa\n\tu8Array[0] = 0;\n\treturn f32Array[0];\n}\n\nlet keyCache = new Array(4096)\nfunction readKey() {\n\tlet length = src[position++]\n\tif (length >= 0x60 && length < 0x78) {\n\t\t// fixstr, potentially use key cache\n\t\tlength = length - 0x60\n\t\tif (srcStringEnd >= position) // if it has been extracted, must use it (and faster anyway)\n\t\t\treturn srcString.slice(position - srcStringStart, (position += length) - srcStringStart)\n\t\telse if (!(srcStringEnd == 0 && srcEnd < 180))\n\t\t\treturn readFixedString(length)\n\t} else { // not cacheable, go back and do a standard read\n\t\tposition--\n\t\treturn read()\n\t}\n\tlet key = ((length << 5) ^ (length > 1 ? dataView.getUint16(position) : length > 0 ? src[position] : 0)) & 0xfff\n\tlet entry = keyCache[key]\n\tlet checkPosition = position\n\tlet end = position + length - 3\n\tlet chunk\n\tlet i = 0\n\tif (entry && entry.bytes == length) {\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = dataView.getUint32(checkPosition)\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tcheckPosition += 4\n\t\t}\n\t\tend += 3\n\t\twhile (checkPosition < end) {\n\t\t\tchunk = src[checkPosition++]\n\t\t\tif (chunk != entry[i++]) {\n\t\t\t\tcheckPosition = 0x70000000\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (checkPosition === end) {\n\t\t\tposition = checkPosition\n\t\t\treturn entry.string\n\t\t}\n\t\tend -= 3\n\t\tcheckPosition = position\n\t}\n\tentry = []\n\tkeyCache[key] = entry\n\tentry.bytes = length\n\twhile (checkPosition < end) {\n\t\tchunk = dataView.getUint32(checkPosition)\n\t\tentry.push(chunk)\n\t\tcheckPosition += 4\n\t}\n\tend += 3\n\twhile (checkPosition < end) {\n\t\tchunk = src[checkPosition++]\n\t\tentry.push(chunk)\n\t}\n\t// for small blocks, avoiding the overhead of the extract call is helpful\n\tlet string = length < 16 ? shortStringInJS(length) : longStringInJS(length)\n\tif (string != null)\n\t\treturn entry.string = string\n\treturn entry.string = readFixedString(length)\n}\n\nexport class Tag {\n\tconstructor(value, tag) {\n\t\tthis.value = value\n\t\tthis.tag = tag\n\t}\n}\n\ncurrentExtensions[0] = (dateString) => {\n\t// string date extension\n\treturn new Date(dateString)\n}\n\ncurrentExtensions[1] = (epochSec) => {\n\t// numeric date extension\n\treturn new Date(Math.round(epochSec * 1000))\n}\n\ncurrentExtensions[2] = (buffer) => {\n\t// bigint extension\n\tlet value = BigInt(0)\n\tfor (let i = 0, l = buffer.byteLength; i < l; i++) {\n\t\tvalue = BigInt(buffer[i]) + value << BigInt(8)\n\t}\n\treturn value\n}\n\ncurrentExtensions[3] = (buffer) => {\n\t// negative bigint extension\n\treturn BigInt(-1) - currentExtensions[2](buffer)\n}\ncurrentExtensions[4] = (fraction) => {\n\t// best to reparse to maintain accuracy\n\treturn +(fraction[1] + 'e' + fraction[0])\n}\n\ncurrentExtensions[5] = (fraction) => {\n\t// probably not sufficiently accurate\n\treturn fraction[1] * Math.exp(fraction[0] * Math.log(2))\n}\n\n// the registration of the record definition extension\nconst recordDefinition = (definition) => {\n\tlet id = definition[0] - 0xe000\n\tlet structure = definition[1]\n\tlet existingStructure = currentStructures[id]\n\tif (existingStructure && existingStructure.isShared) {\n\t\t(currentStructures.restoreStructures || (currentStructures.restoreStructures = []))[id] = existingStructure\n\t}\n\tcurrentStructures[id] = structure\n\n\tstructure.read = createStructureReader(structure)\n\tlet object = {}\n\tif (currentDecoder.keyMap) for (let i = 2,l = definition.length; i < l; i++) {\n\t\t\tlet key = currentDecoder.decodeKey(structure[i - 2])\n\t\t\tobject[safeKey(key)] = definition[i]\n\t\t}\n\telse for (let i = 2,l = definition.length; i < l; i++) {\n\t\t\tlet key = structure[i - 2]\n\t\t\tobject[safeKey(key)] = definition[i]\n\t\t}\n\treturn object\n}\ncurrentExtensions[LEGACY_RECORD_INLINE_ID] = recordDefinition\ncurrentExtensions[14] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[0].slice(bundledStrings.position0, bundledStrings.position0 += value)\n\treturn new Tag(value, 14)\n}\ncurrentExtensions[15] = (value) => {\n\tif (bundledStrings)\n\t\treturn bundledStrings[1].slice(bundledStrings.position1, bundledStrings.position1 += value)\n\treturn new Tag(value, 15)\n}\nlet glbl = { Error, RegExp }\ncurrentExtensions[27] = (data) => { // http://cbor.schmorp.de/generic-object\n\treturn (glbl[data[0]] || Error)(data[1], data[2])\n}\nconst packedTable = (read) => {\n\tif (src[position++] != 0x84)\n\t\tthrow new Error('Packed values structure must be followed by a 4 element array')\n\tlet newPackedValues = read() // packed values\n\tpackedValues = packedValues ? newPackedValues.concat(packedValues.slice(newPackedValues.length)) : newPackedValues\n\tpackedValues.prefixes = read()\n\tpackedValues.suffixes = read()\n\treturn read() // read the rump\n}\npackedTable.handlesRead = true\ncurrentExtensions[51] = packedTable\n\ncurrentExtensions[PACKED_REFERENCE_TAG_ID] = (data) => { // packed reference\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\treturn new Tag(data, PACKED_REFERENCE_TAG_ID)\n\t}\n\tif (typeof data == 'number')\n\t\treturn packedValues[16 + (data >= 0 ? 2 * data : (-2 * data - 1))]\n\tthrow new Error('No support for non-integer packed references yet')\n}\n\n// The following code is an incomplete implementation of http://cbor.schmorp.de/stringref\n// the real thing would need to implemennt more logic to populate the stringRefs table and\n// maintain a stack of stringRef \"namespaces\".\n//\n// currentExtensions[25] = (id) => {\n// \treturn stringRefs[id]\n// }\n// currentExtensions[256] = (read) => {\n// \tstringRefs = []\n// \ttry {\n// \t\treturn read()\n// \t} finally {\n// \t\tstringRefs = null\n// \t}\n// }\n// currentExtensions[256].handlesRead = true\n\ncurrentExtensions[28] = (read) => { \n\t// shareable http://cbor.schmorp.de/value-sharing (for structured clones)\n\tif (!referenceMap) {\n\t\treferenceMap = new Map()\n\t\treferenceMap.id = 0\n\t}\n\tlet id = referenceMap.id++\n\tlet token = src[position]\n\tlet target\n\t// TODO: handle Maps, Sets, and other types that can cycle; this is complicated, because you potentially need to read\n\t// ahead past references to record structure definitions\n\tif ((token >> 5) == 4)\n\t\ttarget = []\n\telse\n\t\ttarget = {}\n\n\tlet refEntry = { target } // a placeholder object\n\treferenceMap.set(id, refEntry)\n\tlet targetProperties = read() // read the next value as the target object to id\n\tif (refEntry.used) // there is a cycle, so we have to assign properties to original target\n\t\treturn Object.assign(target, targetProperties)\n\trefEntry.target = targetProperties // the placeholder wasn't used, replace with the deserialized one\n\treturn targetProperties // no cycle, can just use the returned read object\n}\ncurrentExtensions[28].handlesRead = true\n\ncurrentExtensions[29] = (id) => {\n\t// sharedref http://cbor.schmorp.de/value-sharing (for structured clones)\n\tlet refEntry = referenceMap.get(id)\n\trefEntry.used = true\n\treturn refEntry.target\n}\n\ncurrentExtensions[258] = (array) => new Set(array); // https://github.com/input-output-hk/cbor-sets-spec/blob/master/CBOR_SETS.md\n(currentExtensions[259] = (read) => {\n\t// https://github.com/shanewholloway/js-cbor-codec/blob/master/docs/CBOR-259-spec\n\t// for decoding as a standard Map\n\tif (currentDecoder.mapsAsObjects) {\n\t\tcurrentDecoder.mapsAsObjects = false\n\t\trestoreMapsAsObject = true\n\t}\n\treturn read()\n}).handlesRead = true\nfunction combine(a, b) {\n\tif (typeof a === 'string')\n\t\treturn a + b\n\tif (a instanceof Array)\n\t\treturn a.concat(b)\n\treturn Object.assign({}, a, b)\n}\nfunction getPackedValues() {\n\tif (!packedValues) {\n\t\tif (currentDecoder.getShared)\n\t\t\tloadShared()\n\t\telse\n\t\t\tthrow new Error('No packed values available')\n\t}\n\treturn packedValues\n}\nconst SHARED_DATA_TAG_ID = 0x53687264 // ascii 'Shrd'\ncurrentExtensionRanges.push((tag, input) => {\n\tif (tag >= 225 && tag <= 255)\n\t\treturn combine(getPackedValues().prefixes[tag - 224], input)\n\tif (tag >= 28704 && tag <= 32767)\n\t\treturn combine(getPackedValues().prefixes[tag - 28672], input)\n\tif (tag >= 1879052288 && tag <= 2147483647)\n\t\treturn combine(getPackedValues().prefixes[tag - 1879048192], input)\n\tif (tag >= 216 && tag <= 223)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 216])\n\tif (tag >= 27647 && tag <= 28671)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 27639])\n\tif (tag >= 1811940352 && tag <= 1879048191)\n\t\treturn combine(input, getPackedValues().suffixes[tag - 1811939328])\n\tif (tag == SHARED_DATA_TAG_ID) {// we do a special check for this so that we can keep the currentExtensions as densely stored array (v8 stores arrays densely under about 3000 elements)\n\t\treturn {\n\t\t\tpackedValues: packedValues,\n\t\t\tstructures: currentStructures.slice(0),\n\t\t\tversion: input,\n\t\t}\n\t}\n\tif (tag == 55799) // self-descriptive CBOR tag, just return input value\n\t\treturn input\n})\n\nconst isLittleEndianMachine = new Uint8Array(new Uint16Array([1]).buffer)[0] == 1\nexport const typedArrays = [Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array,\n\ttypeof BigUint64Array == 'undefined' ? { name:'BigUint64Array' } : BigUint64Array, Int8Array, Int16Array, Int32Array,\n\ttypeof BigInt64Array == 'undefined' ? { name:'BigInt64Array' } : BigInt64Array, Float32Array, Float64Array]\nconst typedArrayTags = [64, 68, 69, 70, 71, 72, 77, 78, 79, 85, 86]\nfor (let i = 0; i < typedArrays.length; i++) {\n\tregisterTypedArray(typedArrays[i], typedArrayTags[i])\n}\nfunction registerTypedArray(TypedArray, tag) {\n\tlet dvMethod = 'get' + TypedArray.name.slice(0, -5)\n\tif (typeof TypedArray !== 'function')\n\t\tTypedArray = null;\n\tlet bytesPerElement = TypedArray.BYTES_PER_ELEMENT\n\tfor (let littleEndian = 0; littleEndian < 2; littleEndian++) {\n\t\tif (!littleEndian && bytesPerElement == 1)\n\t\t\tcontinue\n\t\tlet sizeShift = bytesPerElement == 2 ? 1 : bytesPerElement == 4 ? 2 : 3\n\t\tcurrentExtensions[littleEndian ? tag : (tag - 4)] = (bytesPerElement == 1 || littleEndian == isLittleEndianMachine) ? (buffer) => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\t// we have to always slice/copy here to get a new ArrayBuffer that is word/byte aligned\n\t\t\treturn new TypedArray(Uint8Array.prototype.slice.call(buffer, 0).buffer)\n\t\t} : buffer => {\n\t\t\tif (!TypedArray)\n\t\t\t\tthrow new Error('Could not find typed array for code ' + tag)\n\t\t\tlet dv = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\t\t\tlet elements = buffer.length >> sizeShift\n\t\t\tlet ta = new TypedArray(elements)\n\t\t\tlet method = dv[dvMethod]\n\t\t\tfor (let i = 0; i < elements; i++) {\n\t\t\t\tta[i] = method.call(dv, i << sizeShift, littleEndian)\n\t\t\t}\n\t\t\treturn ta\n\t\t}\n\t}\n}\n\nfunction readBundleExt() {\n\tlet length = readJustLength()\n\tlet bundlePosition = position + read()\n\tfor (let i = 2; i < length; i++) {\n\t\t// skip past bundles that were already read\n\t\tlet bundleLength = readJustLength() // this will increment position, so must add to position afterwards\n\t\tposition += bundleLength\n\t}\n\tlet dataPosition = position\n\tposition = bundlePosition\n\tbundledStrings = [readStringJS(readJustLength()), readStringJS(readJustLength())]\n\tbundledStrings.position0 = 0\n\tbundledStrings.position1 = 0\n\tbundledStrings.postBundlePosition = position\n\tposition = dataPosition\n\treturn read()\n}\n\nfunction readJustLength() {\n\tlet token = src[position++] & 0x1f\n\tif (token > 0x17) {\n\t\tswitch (token) {\n\t\t\tcase 0x18:\n\t\t\t\ttoken = src[position++]\n\t\t\t\tbreak\n\t\t\tcase 0x19:\n\t\t\t\ttoken = dataView.getUint16(position)\n\t\t\t\tposition += 2\n\t\t\t\tbreak\n\t\t\tcase 0x1a:\n\t\t\t\ttoken = dataView.getUint32(position)\n\t\t\t\tposition += 4\n\t\t\t\tbreak\n\t\t}\n\t}\n\treturn token\n}\n\nfunction loadShared() {\n\tif (currentDecoder.getShared) {\n\t\tlet sharedData = saveState(() => {\n\t\t\t// save the state in case getShared modifies our buffer\n\t\t\tsrc = null\n\t\t\treturn currentDecoder.getShared()\n\t\t}) || {}\n\t\tlet updatedStructures = sharedData.structures || []\n\t\tcurrentDecoder.sharedVersion = sharedData.version\n\t\tpackedValues = currentDecoder.sharedValues = sharedData.packedValues\n\t\tif (currentStructures === true)\n\t\t\tcurrentDecoder.structures = currentStructures = updatedStructures\n\t\telse\n\t\t\tcurrentStructures.splice.apply(currentStructures, [0, updatedStructures.length].concat(updatedStructures))\n\t}\n}\n\nfunction saveState(callback) {\n\tlet savedSrcEnd = srcEnd\n\tlet savedPosition = position\n\tlet savedStringPosition = stringPosition\n\tlet savedSrcStringStart = srcStringStart\n\tlet savedSrcStringEnd = srcStringEnd\n\tlet savedSrcString = srcString\n\tlet savedStrings = strings\n\tlet savedReferenceMap = referenceMap\n\tlet savedBundledStrings = bundledStrings\n\n\t// TODO: We may need to revisit this if we do more external calls to user code (since it could be slow)\n\tlet savedSrc = new Uint8Array(src.slice(0, srcEnd)) // we copy the data in case it changes while external data is processed\n\tlet savedStructures = currentStructures\n\tlet savedDecoder = currentDecoder\n\tlet savedSequentialMode = sequentialMode\n\tlet value = callback()\n\tsrcEnd = savedSrcEnd\n\tposition = savedPosition\n\tstringPosition = savedStringPosition\n\tsrcStringStart = savedSrcStringStart\n\tsrcStringEnd = savedSrcStringEnd\n\tsrcString = savedSrcString\n\tstrings = savedStrings\n\treferenceMap = savedReferenceMap\n\tbundledStrings = savedBundledStrings\n\tsrc = savedSrc\n\tsequentialMode = savedSequentialMode\n\tcurrentStructures = savedStructures\n\tcurrentDecoder = savedDecoder\n\tdataView = new DataView(src.buffer, src.byteOffset, src.byteLength)\n\treturn value\n}\nexport function clearSource() {\n\tsrc = null\n\treferenceMap = null\n\tcurrentStructures = null\n}\n\nexport function addExtension(extension) {\n\tcurrentExtensions[extension.tag] = extension.decode\n}\n\nexport const mult10 = new Array(147) // this is a table matching binary exponents to the multiplier to determine significant digit rounding\nfor (let i = 0; i < 256; i++) {\n\tmult10[i] = +('1e' + Math.floor(45.15 - i * 0.30103))\n}\nlet defaultDecoder = new Decoder({ useRecords: false })\nexport const decode = defaultDecoder.decode\nexport const decodeMultiple = defaultDecoder.decodeMultiple\nexport const FLOAT32_OPTIONS = {\n\tNEVER: 0,\n\tALWAYS: 1,\n\tDECIMAL_ROUND: 3,\n\tDECIMAL_FIT: 4\n}\nexport function roundFloat32(float32Number) {\n\tf32Array[0] = float32Number\n\tlet multiplier = mult10[((u8Array[3] & 0x7f) << 1) | (u8Array[2] >> 7)]\n\treturn ((multiplier * float32Number + (float32Number > 0 ? 0.5 : -0.5)) >> 0) / multiplier\n}\n", "import {\n    decode as _fromBase64Url,\n    encode as _toBase64Url,\n} from '@cfworker/base64url';\n\nexport { decode as cborDecode } from 'cbor-x/decode';\n\nconst encoder = new TextEncoder();\nconst decoder = new TextDecoder();\nexport const encode = encoder.encode.bind(encoder);\nexport const decode = decoder.decode.bind(decoder);\n\nexport const byteStringToBuffer = (byteString: string) =>\n    Uint8Array.from(byteString, (e) => e.charCodeAt(0)).buffer;\n\nexport const bufferToByteString = (buffer: ArrayBuffer) =>\n    String.fromCharCode(...new Uint8Array(buffer));\n\nexport const toBase64Url = _toBase64Url;\nexport const fromBase64Url = _fromBase64Url;\nexport const marshal = (data: object) => toBase64Url(JSON.stringify(data));\nexport const unmarshal = (data: string) => JSON.parse(fromBase64Url(data));\n\nexport const safeEncode = (data: string) => encode(fromBase64Url(data));\nexport const safeDecode = (data: ArrayBuffer) => toBase64Url(decode(data));\nexport const safeByteEncode = (data: string) =>\n    byteStringToBuffer(fromBase64Url(data));\nexport const safeByteDecode = (data: ArrayBuffer) =>\n    toBase64Url(bufferToByteString(data));\n\nexport function concatBuffer(buffer1: ArrayBuffer, buffer2: ArrayBuffer) {\n    let tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp.buffer;\n}\n\nexport function isBiggerBuffer(a: ArrayBuffer, b: ArrayBuffer) {\n    const dvA = new DataView(a);\n    const dvB = new DataView(b);\n\n    if (dvA.byteLength > dvB.byteLength) {\n        return true;\n    }\n\n    for (let i = 0; i < dvA.byteLength; i++) {\n        if (dvA.getUint8(i) > dvB.getUint8(i)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nexport function isEqualBuffer(a: ArrayBuffer, b: ArrayBuffer) {\n    const dvA = new DataView(a);\n    const dvB = new DataView(b);\n\n    if (dvA.byteLength !== dvB.byteLength) {\n        return false;\n    }\n\n    for (let i = 0; i < dvA.byteLength; i++) {\n        if (dvA.getUint8(i) !== dvB.getUint8(i)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nconst UUID_V4_REGEX =\n    /^[0-9A-F]{8}-[0-9A-F]{4}-[4][0-9A-F]{3}-[89AB][0-9A-F]{3}-[0-9A-F]{12}$/i;\n\nexport function isUUIDv4(uuid: string) {\n    return UUID_V4_REGEX.test(uuid);\n}\n", "import * as schema from '../server/schema.js';\nimport { cborDecode, decode, safeByteDecode } from '../utils.js';\n\nconst makeRequest = (endpoint: string, data: object = {}) =>\n    fetch(\n        new Request(`https://api.passkeys.neal.codes/${endpoint}`, {\n            method: 'POST',\n            headers: {\n                'Content-Type': 'application/json',\n            },\n            body: JSON.stringify(data),\n            credentials: 'include',\n        })\n    );\n\nexport namespace Attestation {\n    export async function generate(userId: string) {\n        const response = await makeRequest('attestation/generate', {\n            userId,\n        } as schema.Attestation.ChallengePayload);\n        return (await response.json()) as schema.Attestation.ChallengeResponse;\n    }\n\n    export async function store(credential: PublicKeyCredential) {\n        const attestation =\n            credential.response as AuthenticatorAttestationResponse;\n\n        // DEBUG:\n        console.log(JSON.parse(decode(attestation.clientDataJSON)));\n        // DEBUG:\n        console.log(cborDecode(new Uint8Array(attestation.attestationObject)));\n        // DEBUG:\n        // @ts-ignore\n        window.attestation = credential;\n\n        const payload: schema.Attestation.StoreCredentialPayload = {\n            kid: credential.id,\n            clientDataJSON: safeByteDecode(attestation.clientDataJSON),\n            attestationObject: safeByteDecode(attestation.attestationObject),\n            pubkey: safeByteDecode(attestation.getPublicKey() as ArrayBuffer),\n            coseAlg: attestation.getPublicKeyAlgorithm(),\n        };\n\n        const response = await makeRequest('attestation/store', payload);\n        return (await response.json()) as schema.Attestation.StoreCredentialResponse;\n    }\n}\n\nexport namespace Assertion {\n    export async function generate() {\n        const response = await makeRequest(\n            'assertion/generate',\n            {} as schema.Assertion.ChallengePayload\n        );\n        return (await response.json()) as schema.Assertion.ChallengeResponse;\n    }\n\n    export async function verify(credential: PublicKeyCredential) {\n        const assertion = credential.response as AuthenticatorAssertionResponse;\n\n        // DEBUG:\n        console.log(JSON.parse(decode(assertion.clientDataJSON)));\n        // DEBUG:\n        console.log(assertion.authenticatorData);\n        // DEBUG:\n        // @ts-ignore\n        window.assertion = credential;\n\n        const payload: schema.Assertion.VerifyPayload = {\n            kid: credential.id,\n            clientDataJSON: safeByteDecode(assertion.clientDataJSON),\n            authenticatorData: safeByteDecode(assertion.authenticatorData),\n            signature: safeByteDecode(assertion.signature),\n        };\n        const response = await makeRequest('assertion/verify', payload);\n        return (await response.json()) as schema.Assertion.VerifyResponse;\n    }\n}\n", "import { safeEncode } from '../utils.js';\nimport * as api from './api.js';\n\nexport async function assertion(abortController: AbortController) {\n    const { challenge } = await api.Assertion.generate();\n    const publicKey: PublicKeyCredentialRequestOptions = {\n        challenge: safeEncode(challenge),\n        rpId: window.location.host,\n        timeout: 60_000,\n    };\n\n    // const mediation =\n    //     /*\n    //      * Optional fills the need in most cases, but we can use conditional if wanted\n    //      * https://w3c.github.io/webappsec-credential-management/#dom-credentialmediationrequirement-conditional\n    //      */\n    //     // @ts-ignore\n    //     (await PublicKeyCredential?.isConditionalMediationAvailable?.())\n    //         ? 'conditional'\n    //         : 'optional';\n\n    const credential = (await window.navigator.credentials.get({\n        publicKey,\n        signal: abortController.signal,\n        mediation: 'optional',\n    })) as PublicKeyCredential;\n    return await api.Assertion.verify(credential);\n}\n", "import { byteStringToBuffer } from './utils';\n\nexport enum Digests {\n    SHA256 = 'SHA-256',\n    SHA384 = 'SHA-384',\n    SHA512 = 'SHA-512',\n}\n\nexport enum SigningAlg {\n    ECDSA = 'ECDSA',\n}\n\nexport enum COSEAlgorithm {\n    ES256 = -7,\n    ES384 = -35,\n    ES512 = -36,\n    // RS256 = -257,\n    // RS384 = -258,\n    // RS512 = -259,\n}\n\nexport enum SigningCurve {\n    P256 = 'P-256',\n    P384 = 'P-384',\n    P512 = 'P-512',\n}\n\nexport const COSEAlgToDigest = {\n    [COSEAlgorithm.ES256.toString()]: Digests.SHA256,\n    [COSEAlgorithm.ES384.toString()]: Digests.SHA384,\n    [COSEAlgorithm.ES512.toString()]: Digests.SHA512,\n};\n\nexport const COSEAlgToSigningCurve = {\n    [COSEAlgorithm.ES256.toString()]: SigningCurve.P256,\n    [COSEAlgorithm.ES384.toString()]: SigningCurve.P384,\n    [COSEAlgorithm.ES512.toString()]: SigningCurve.P512,\n};\n\nexport const COSEAlgToSigningAlg = {\n    [COSEAlgorithm.ES256.toString()]: SigningAlg.ECDSA,\n    [COSEAlgorithm.ES384.toString()]: SigningAlg.ECDSA,\n    [COSEAlgorithm.ES512.toString()]: SigningAlg.ECDSA,\n};\n\nexport const stringTimingSafeEqual = (a: string, b: string): boolean => {\n    // @ts-ignore\n    return crypto.subtle.timingSafeEqual(\n        byteStringToBuffer(a),\n        byteStringToBuffer(b)\n    );\n};\n\nexport class Crypto {\n    static async toCryptoKey(\n        pubKey: ArrayBuffer,\n        name: SigningAlg,\n        namedCurve: SigningCurve\n    ) {\n        return await crypto.subtle.importKey(\n            'spki',\n            pubKey,\n            { name, namedCurve },\n            true,\n            ['verify']\n        );\n    }\n}\n", "import { COSEAlgorithm } from '../crypto.js';\nimport { encode, safeEncode } from '../utils.js';\nimport * as api from './api.js';\n\nexport async function attestation(\n    abortController: AbortController,\n    username: string\n) {\n    const userId = crypto.randomUUID();\n    const { challenge } = await api.Attestation.generate(userId);\n    const publicKey: PublicKeyCredentialCreationOptions = {\n        challenge: safeEncode(challenge),\n        rp: {\n            id: window.location.host,\n            name: document.title,\n        },\n        user: {\n            id: encode(userId),\n            name: username,\n            displayName: '',\n        },\n        pubKeyCredParams: [\n            {\n                type: 'public-key',\n                alg: COSEAlgorithm.ES512,\n            },\n            {\n                type: 'public-key',\n                alg: COSEAlgorithm.ES384,\n            },\n            {\n                type: 'public-key',\n                alg: COSEAlgorithm.ES256,\n            },\n        ],\n        authenticatorSelection: {\n            userVerification: 'preferred',\n            residentKey: 'required',\n        },\n        attestation: 'indirect',\n        timeout: 60_000,\n    };\n\n    const credential = (await window.navigator.credentials.create({\n        publicKey,\n        signal: abortController.signal,\n    })) as PublicKeyCredential;\n    return await api.Attestation.store(credential);\n}\n", "export const form = document.querySelector('form#passkeys') as HTMLFormElement;\nexport const signupButton = form.querySelector('button#signup');\nexport const loginButton = form.querySelector('button#login');\n\nexport const output = document.querySelector(\n    'textarea#output'\n) as HTMLTextAreaElement;\n", "import { assertion } from './assertion.js';\nimport { attestation } from './attestation.js';\nimport * as dom from './dom.js';\n\nif (\n    window.PublicKeyCredential\n    /*\n     * This can be uncommented if you require a secondary authentication factor on the device\n     * https://developer.mozilla.org/en-US/docs/Web/API/PublicKeyCredential/isUserVerifyingPlatformAuthenticatorAvailable\n     */\n    // && (await PublicKeyCredential?.isUserVerifyingPlatformAuthenticatorAvailable?.())\n) {\n    dom.form.addEventListener('submit', (e) => {\n        e.preventDefault();\n        return false;\n    });\n\n    const submit = (fn: CallableFunction) => async (e: Event) => {\n        e.preventDefault();\n        const data = new FormData(dom.form);\n        const abortController = new AbortController();\n        const username = data.get('username');\n        if (e.target === dom.signupButton && !username) {\n            return dom.form.reportValidity();\n        }\n\n        if (dom.output) {\n            dom.output.value = '';\n        }\n        const response = await fn(abortController, username);\n        if (dom.output) {\n            dom.output.value = JSON.stringify(response, undefined, 4);\n        }\n    };\n\n    dom.signupButton?.addEventListener('click', submit(attestation));\n    dom.loginButton?.addEventListener('click', submit(assertion));\n}\n"],
  "mappings": "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",
  "names": ["require_lib", "__commonJSMin", "exports", "parse", "string", "encoding", "opts", "_opts$out", "i", "end", "out", "bits", "buffer", "written", "_i", "value", "stringify", "data", "_opts", "_opts$pad", "pad", "mask", "base16Encoding", "base32Encoding", "base32HexEncoding", "base64Encoding", "base64UrlEncoding", "base16", "base32", "base32hex", "base64", "base64url", "codec", "import_index", "base16", "cjs", "base32", "base32hex", "base64", "base64url", "codec", "decode", "s", "base64url", "encode", "s", "base64url", "decoder", "src", "srcEnd", "position", "EMPTY_ARRAY", "LEGACY_RECORD_INLINE_ID", "RECORD_DEFINITIONS_ID", "RECORD_INLINE_ID", "BUNDLED_STRINGS_ID", "PACKED_REFERENCE_TAG_ID", "STOP_CODE", "strings", "EMPTY_ARRAY", "stringPosition", "currentDecoder", "currentStructures", "srcString", "srcStringStart", "srcStringEnd", "bundledStrings", "referenceMap", "currentExtensions", "currentExtensionRanges", "packedValues", "dataView", "restoreMapsAsObject", "defaultOptions", "sequentialMode", "Decoder", "options", "k", "v", "key", "rec", "map", "res", "safeKey", "source", "end", "r", "src", "saveState", "clearSource", "srcEnd", "position", "error", "checkedRead", "forEach", "values", "lastPosition", "size", "value", "defaultDecoder", "checkedRead", "result", "read", "bundledStrings", "position", "error", "srcEnd", "currentStructures", "src", "referenceMap", "sequentialMode", "clearSource", "token", "majorType", "getFloat16", "dataView", "value", "currentDecoder", "multiplier", "mult10", "array", "i", "STOP_CODE", "key", "object", "safeKey", "restoreMapsAsObject", "map", "readBin", "srcStringEnd", "srcString", "srcStringStart", "string", "shortStringInJS", "longStringInJS", "readFixedString", "BUNDLED_STRINGS_ID", "structure", "createStructureReader", "RECORD_INLINE_ID", "recordDefinition", "RECORD_DEFINITIONS_ID", "length", "readJustLength", "id", "readBundleExt", "loadShared", "extension", "currentExtensions", "input", "currentExtensionRanges", "Tag", "packedValue", "packedValues", "getPackedValues", "validName", "readObject", "compiledReader", "k", "readStringJS", "readStringJS", "length", "result", "shortStringInJS", "decoder", "src", "position", "end", "units", "byte1", "byte2", "byte3", "byte4", "unit", "fromCharCode", "longStringInJS", "start", "bytes", "byte", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "readBin", "currentDecoder", "f32Array", "u8Array", "getFloat16", "byte0", "src", "position", "byte1", "exponent", "abs", "keyCache", "Tag", "value", "tag", "currentExtensions", "dateString", "epochSec", "buffer", "i", "l", "fraction", "recordDefinition", "definition", "id", "structure", "existingStructure", "currentStructures", "createStructureReader", "object", "currentDecoder", "key", "safeKey", "LEGACY_RECORD_INLINE_ID", "bundledStrings", "glbl", "data", "packedTable", "read", "src", "position", "newPackedValues", "packedValues", "PACKED_REFERENCE_TAG_ID", "loadShared", "referenceMap", "token", "target", "refEntry", "targetProperties", "array", "restoreMapsAsObject", "combine", "a", "b", "getPackedValues", "SHARED_DATA_TAG_ID", "currentExtensionRanges", "input", "isLittleEndianMachine", "typedArrays", "typedArrayTags", "registerTypedArray", "TypedArray", "dvMethod", "bytesPerElement", "littleEndian", "sizeShift", "dv", "elements", "ta", "method", "readBundleExt", "length", "readJustLength", "bundlePosition", "bundleLength", "dataPosition", "readStringJS", "dataView", "sharedData", "saveState", "updatedStructures", "callback", "savedSrcEnd", "srcEnd", "savedPosition", "savedStringPosition", "stringPosition", "savedSrcStringStart", "srcStringStart", "savedSrcStringEnd", "srcStringEnd", "savedSrcString", "srcString", "savedStrings", "strings", "savedReferenceMap", "savedBundledStrings", "savedSrc", "savedStructures", "savedDecoder", "savedSequentialMode", "sequentialMode", "clearSource", "mult10", "i", "defaultDecoder", "Decoder", "decode", "decodeMultiple", "encoder", "decoder", "encode", "decode", "bufferToByteString", "buffer", "toBase64Url", "encode", "fromBase64Url", "decode", "safeEncode", "data", "encode", "fromBase64Url", "safeByteDecode", "data", "toBase64Url", "bufferToByteString", "makeRequest", "endpoint", "data", "Attestation", "generate", "userId", "store", "credential", "attestation", "decode", "payload", "safeByteDecode", "Assertion", "verify", "assertion", "assertion", "abortController", "challenge", "Assertion", "publicKey", "safeEncode", "credential", "COSEAlgToDigest", "COSEAlgToSigningCurve", "COSEAlgToSigningAlg", "attestation", "abortController", "username", "userId", "challenge", "Attestation", "publicKey", "safeEncode", "encode", "credential", "form", "signupButton", "loginButton", "output", "form", "e", "submit", "fn", "data", "abortController", "username", "signupButton", "output", "response", "attestation", "loginButton", "assertion"]
}
